#Process Management
##Programs, Processes, and Threads
A program is compiled, executable code lying dormant on a storage medium such as a disk.

A process is a running program. A thread is the unit of activity inside of a process. Each thread has its own virtualized processor, which includes a stack, processor state such as registers, and an instruction pointer.

##The Process ID
Each process is represented by a unique identifier, the process ID.

###Process ID Allocation
By default, the kernel imposes a maximum process ID value of 32768. This is compatibility with older Unix systems, which used signed 16-bit types for process IDs. The kernel allocates process IDs to processes in a strictly linear fashion.

###The Process Hierarchy
The process that spawns a new process is known as the parent; the new process is known as the child. Each process is owned by a user and a group. This ownership is used to control access rights to resources. Each process is also part of a process group, which simply express its relationship to other processes.

###pid_t
Programmatically, the process ID is represented by the pid_t type, which defined in the header file `<sys/types.h>`.

###Obtaining the Process ID and Parent Process ID
The `getpid()` system call returns the process ID of the invoking process:

```C
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
```

The `getppid()` system call returns the process ID of the invoking process's parent:

```C
#include <sys/types.h>
#include <unistd.h>

pid_t getppid(void);
```

##Running a New Process
###The Exec Family of Calls
```C
#include <unistd.h>

int execl(const char* path,
		  const char* arg,
		  ...);
		  
// the following code replaces the currently executing program with /bin/vi
int ret;

ret = execel("/bin/vi", "vi", NULL);
```

A call to `execl()` replaces the current process image with a new one by loading into memory the program pointed at by path. The parameter arg is the first argument to this program. The ellipsis signifies a variable number of arguments--the `execl()` function is variadic. The list of arguments must be NULL-terminated.

A successful `execl()` call changes not only the address space and process image, but also other attributes of the process:

- Any pending signals are lost.
- Any signals that the process is catching are returned to their default behavior, as the signal handlers no longer exist in the process's address space.
- Any memory locks are dropped.
- Most thread attributes are returned to the default values.
- Most process statistics are reset.
- Anything related to the process's memory address space, including any mapped files, is created.
- Anything that exists solely in user space, including features of the C library, such as `atexit()` behavior, is cleared.

Some properties of the process, however, do not change. For example, the pid, parent pid, priority, and owning user and group all remain the same.

Normally, open files are inherited across an exec. This means the newly executed program has full access to all of the files open in the original process.

####The rest of the family
```C
#include <unistd.h>

int execlp(const char* file,
		   const char* arg,
		   ...);

int execle(const char* path,
		   const char* arg,
		   ...,
		   char * const envp[]);

int execv(const char* path, char *const argv[]);

int execvp(const char* file, char * const argv[]);

int execve(const char* filename,
		   char *const argv[],
		   char *const envp[]);
```

The l and v delineate whether the arguments are provided via a list or an array. The p denotes that the user's full path is searched for the given file. The e notes that a new environment is also supplied for the new process.

###The fork() system call

```C
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```



##Terminating a Process
##Waiting for Terminated Child Processes
##Users and Groups
##Sessions and Process Groups
##Daemons