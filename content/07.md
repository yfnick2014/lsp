#Threading
##Binaries, Processes, and Threads
Binaries are dormant programs residing on a storage medium, compiled to a format accessible by a given operating system and machine architecture, ready to execute but not yet in motion. Processes are the operating system abstraction representing those binaries in action: the loaded binary, virtualized memory, kernel resources such as open files, an associated user, and so on. Threads are the unit of execution within a process: a virtualized processor, a stack, and program state.
##Multithreading
benefits to multithreading: 

- Programming abstraction. Dividing up work and assigning each division to a unit of execution is a natural approach to many problems.
- Parallelism. In machines with multiple processors, threads provide an efficient way to achieve true parallelism.
- Improving responsiveness. Even on a uniprocessor machine, multithreading can improve a process's responsiveness.
- Blocking I/O. Without threads, blocking I/O halts the entire process.
- Context switching. The cost of switching from one thread to a different thread within the same process is significantly cheaper than process-to-process context switching.
- Memory savings. Threads provide an efficient way to share memory yet utilize multiple units of execution.

###Context switching: Processes Versus Threads
Machine architecture imposes costs to process switching that threads do not bear, as process switching involves swapping out one virtual address space for another. On x86, for example, the translation lookaside buffer(TLB), which is a cache mapping virtual to physical memory addresses, must be flushed when swapping out the virtual address space. TLB misses are incredibly detrimental to system performance. Threads do not bear these costs, as thread-to-thread switching does not swap out the virtual address space.

###Costs of Multithreading
Designing, writing, understanding, and debugging multithreading programs is significantly more difficult than a single-threaded process.

###Alternatives to Multithreading
The latency and I/O benefits to threading are attainable via a combination of multiplexed I/O, nonblocking I/O, and asynchronous I/O. If true parallelism is your goal, N processes can achieve the same processor utilization as N threads, albeit at some cost of increased resource consumption and context switching overhead. Conversely, if memory saving is your goal, Linux provides tools to share memory in a more limited manner than threads.

##Threading Models
###User-Level Threading

###Hybrid Threading

###Coroutines and Fibers

##Threading Patterns
##Concurrency, Parallelism, and Races
##Synchronization
##Pthreads