#Buffered I/O
##User-Buffered I/O

```Shell
dd bs=1 count=2097152 if=/dev/zero of=pirate

dd bs=1024 count=2048 if=/dev/zero of=pirate
```

Table. Effects of block size on performance

<table>
<tr>
<th>Block Size</th>
<th>Real Time</th>
<th>User Time</th>
<th>System Time</th>
</tr>
<tr>
<td>1 byte</td>
<td>18.707 seconds</td>
<td>1.118 seconds</td>
<td>17.549 seconds</td>
</tr>
<tr>
<td>1,024 byte</td>
<td>0.025 seconds</td>
<td>0.002 seconds</td>
<td>0.023 seconds</td>
</tr>
<tr>
<td>1,130 byte</td>
<td>0.035 seconds</td>
<td>0.002 seconds</td>
<td>0.0027 seconds</td>
</tr>
</table>
###Block Size
A large performance gain is realized simply by performing operations in chunks that are integer multiples or divisors of the block size.

It is possible to implement user buffering by hand in your own programs. Indeed, many mission-critical applications do just that. The vast majority of programs, however, make use of the popular standard I/O library(part of the standard C library) or the iostream(part of the standard C++ library), which provides a robust and capable user-buffering solution.
##Standard I/O
The standard C library provides the standard I/O library(often simply called stdio), which in turn provides a platform-independent, user-buffering solution.

Standard I/O routines do not operate directly on file descriptors. Instead, they use their own unique identifier, known as the file pointer. Inside the C library, the file pointer maps to a file descriptor.
##Opening Files
```C
#include <stdio.h>

FILE *fopen(const char *path, const char *mode);
```
`mode` argument:

- r (open the file for reading)
- r+ (open the file both for reading and writing)
- w (open the file for writing. If the file exists, it is truncated to zero length. If the file does not exist, it is created)
- w+ (open the file for reading and writing. If the file exists, it is truncated to zero length. If the file does not exist, it is created)
- a (open the file for writing in append mode. The file is created if it does not exist)
- a+ (open the file both for reading and writing in append mode. The file is created if it does not exist)

Upon success, `fopen()` returns a valid FILE pointer. On failure, it returns NULL and sets errno appropriately.

##Opening a Stream via File Descriptor
##Closing Streams
##Reading from a Stream
##Writing to a Stream
##Sample Program Using Buffered I/O
##Seeking a Stream
##Flushing a Stream
##Errors and End-of-File
##Obtaining the Associated File Descriptor
##Controlling the Buffering
##Thread Safety
##Critiques of Standard I/O