#File and Directory Management
##Files and Their Metadata
An inode is both a physical object located on the disk of a Unix-style filesystem and a conceptual entity represented by a data structure in the Linux kernel. The inode stores the metadata associated with a file, such as the file's access permissions, last access timestamp, owner, group, and size, as well as the location of the file's data.

###The Stat Family
```C
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *path, struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *path, struct stat *buf);

struct stat {
	dev_t st_dev;		/* ID of device containing file */
	ino_t st_ino;		/* inode number */
	mode_t st_mode;		/* permissions */
	nlink_t st_nlink;	/* number of hard links */
	uid_t st_uid;		/* user ID of owner */
	gid_t st_gid;		/* group ID of owner */
	dev_t st_rdev;		/* device ID (if special file) */
	off_t st_size; 		/* total size in bytes */
	blksize_t st_blksize; /* blocksize for filesystem I/O */
	blkcnt_t st_blocks; /* number of blocks allocated */
	time_t st_atime; 	/* last access time */
	time_t st_mtime; 	/* last modification time */
	time_t st_ctime; 	/* last status change time */
};
```

`stat()` returns information about the file denoted by the path `path`, while `fstat()` returns information about the file represented by the file descriptor `fd`. `lstat()` is identical to `stat()`, except that in the case of a symbolic link, `lstat()` returns information about the link itself and not the target file.

###Permissions
```C
#include <sys/types.h>
#include <sys/stat.h>

int chmod(const char* path, mode_t mode);
int fchmod(int fd, mode_t mode);
```

Both `chmod()` and `fchmod()` set a file's permissions to mode. With `chmod()`, path denotes the relative or absolute pathname of the file to modify. For `fchmod()`, the file is given by the file descriptor fd.

###Ownership
```C
#include <sys/types.h>
#include <unistd.h>

int chown(const char* path, uid_t owner, gid_t group);
int lchown(const char* path, uid_t owner, gid_t group);
itn fchown(int fd, uid_t owner, gid_t group);
```

`chown()` and `lchown()` set the ownership of the file specified by the path `path`. They have the same effect, unless the file is a symbolic file: the former follows symbolic links and changes the owership of the link target rather than the link itself, while `lchown()` does not follow symbolic links and therefore changes the ownership of the symbolic link file instead. `fchown()` sets the ownership of the file represented by the `fd` file descriptor.

###Extended attributes
Extended attributes, also called xattrs, provide a mechanism for associating key/value pairs with files. Extended attributes allow existing filesystem to support new features that weren't anticipated in their original designs, such as mandatory access controls for security.

####Retrieving an extended attribute
```C
#include <sys/types.h>
#include <attr/xattr.h>

ssize_t getxattr(const char* path, const char* key,
				 void *value, size_t size);
ssize_t lgetxattr(const char* path, const char* key,
				 void *value, size_t size);
ssize_T fgetxattr(int fd, const char* key,
				 void *value, size_t size);
```

####Setting an extended attribute
```C
#include <sys/types.h>
#include <attr/xattr.h>

int setxattr(const char* path, const char* key,
			 const void *value, size_t size, int flags);
int lsetxattr(const char* path, const char* key,
			 const void *value, size_t size, int flags);
int fsetxattr(int fd, const char* key,
			 const void *value, size_t size, int flags);
```

####Listing the extended attributes on a file
```C
#include <sys/types.h>
#include <attr/xattr.h>

ssize_t listxattr(const char* path,
				  char *list, size_t size);
ssize_t llistxattr(const char* path,
				  char *list, size_t size);
ssize_t flistxattr(int fd,
				  char *list, size_t size);
```

####Removing an extended attribute
```C
#include <sys/types.h>
#include <attr/xattr.h>

int removexattr(const char* path, const char* key);
int lremovexattr(const char* path, const char* key);
int fremovexattr(int fd, const char* key);
```

##Directories
In Unix, a directory is a simple concept: it contains a list of filenames, each of which maps to an inode number. Each name is called a directory entry, and each name-to-inode mapping is called a link.

###The Current Working Directory
####Obtaining the current working directory
```C
#include <unistd.h>

char *getcwd(char *buf, size_t size);
```

A successful call to `getcwd()` copies the current working directory as an absolute pathname into the buffer pointed by `buf`, which is of length `size` bytes and returns a pointer to `buf`.

####Chaning the current working directory
```C
#include <unistd.h>

int chdir(const char* path);
int fchdir(int fd);
```

A call to `chdir()` changes the current working directory to the pathname specified by `path`, which can be an absolute or relative pathname. Similarly, a call to `fchdir()` changes the current working directory to the pathname represented by the file descriptor `fd`, which must be opened against a directory.

###Creating Directories
```C
#include <sys/stat.h>
#include <sys/types.h>

int mkdir(const char* path, mode_t mode);
```

###Removing Directories
```C
#include <unistd.h>

int rmdir(const char* path);
```

###Reading a Directory's Contents
To begin reading a directory's contents you need to create a directory stream, which is represented by a `DIR` object:

```C
#include <sys/types.h>
#include <dirent.h>

DIR *opendir(const char* name);

// obtain the fd behind a given directory stream
int dirfd(DIR *dir);
```

####Reading from a directory stream
```C
#include <sys/types.h>
#include <dirent.h>

struct dirent *readdir(DIR *dir);

struct dirent {
	ino_t d_ino; /* inode number */
	off_t d_off; /* offset to the next dirent */
	unsigned short d_reclen; /* length of this record */
	unsigned char d_type; /* type of file */
	char d_name[256]; /* filename */
};
```
A successful call to `readdir()` returns the next entry in the directory represented by `dir`.

####Closing the directory stream
```C
#include <sys/types.h>
#include <dirent.h>

int closedir(DIR *dir);
```

####System calls for reading directory contents
```C
#include <unistd.h>
#include <linux/types.h>
#include <linux/dirent.h>
#include <linux/unistd.h>
#include <errno.h>

int readdir(unsigned int fd,
			struct dirent *dirp,
			unsigned int count);
int getdents(unsigned int fd,
			 struct dirent *dirp,
			 unsigned int count);
```

##Links
A link is essentially just a name in a list(a directory) that points at an inode. Files can have 0, 1, or many links. Files with a link count of 0 have no corresponding directory entries on the filesystem. When a file's link count reaches 0, the file is marked as free, and its disk blocks are made available for reuse. Such a file, however, remains on the filesystem if a process has the file open. Once no process has the file open, the file is removed.

Another type of link, the symbolic link, is not a filesystem mapping, but a higher-level pointer that is interpreted at runtime.

###Hard Links
```C
#include <unistd.h>

int link(const char* oldpath, const char* newpath);
```

###Symbolic Links
```C
#include <unistd.h>

int symlink(const char* oldpath, const char* newpath);
```

###Unlinking
```C
#include <unistd.h>

int unlink(const char* pathname);
```
A successful call to `unlink()` deletes pathname from the filesystem.

##Copying and Moving Files
###Copying
In copying a file `src` to a file named `dst`, the steps are as follows:

1. Open `src`.
2. Open `dst`, creating it if it does not exist, and truncating it to zero length if it does exist.
3. Read a chunk of `src` into memory.
4. Write the chunk to `dst`.
5. Continue until all of `src` has been read and written to `dst`.
6. Close `dst`.
7. Close `src`.

###Moving
```C
#include <stdio.h>

int rename(const char* oldpath, const char* newpath);
```

##Device Nodes
##Out-of-Band Communication
##Monitoring File Events