#Signals
Signals are software interrupts that provide a mechanism for handling asynchronous events.

##Signal Concepts
Signals have a very precise lifecycle. First, a signal is raised. The kernel then stores the signal until it is able to deliver it. Finally, once it is free to do so, the kernel handles the signal as appropriate. The kernel can perform one of three actions, depending on what the process asked it to do:

- Ingnore the signal. No action is taken. There are two signals that cannot be ignored: SIGKILL and SIGSTOP.
- Catch and handle the signal. The kernel will suspend execution of the process's current code path and jump to a previously registered function. The process will then execute this function. Once the process returns from this function, it will jump back to whatever it was when it caught the signal.
- Perform the default action. This actions depends on the signal beging sent. The default action is often to terminate the process.

###Signal Identifiers
Every signal has a symbolic name that starts with the prefix SIG. These signals are all defined in a header file include from `<signal.h>`.

###Signals Supported by Linux

<table>
	<tr>
		<th>Signal</th>
		<th>Description</th>
		<th>Default action</th>
	</tr>
	<tr>
		<td>SIGABRT</td>
		<td>Sent by abort()</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGALRM</td>
		<td>Sent by alarm()</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGBUS</td>
		<td>Hardware or alignment error</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGCHLD</td>
		<td>Child has terminated</td>
		<td>Ignored</td>
	</tr>
	<tr>
		<td>SIGCONT</td>
		<td>Process has continued after being stopped</td>
		<td>Ignored</td>
	</tr>
	<tr>
		<td>SIGFPE</td>
		<td>Arithmetic exception</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGHUP</td>
		<td>Process's controlling terminal was closed(most frequently, the user logged out)</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGILL</td>
		<td>Process tried to execute an illegal instruction</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGINT</td>
		<td>User generated the interrupt character(Ctrl-C)</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGIO</td>
		<td>Asynchronous I/O event</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGKILL</td>
		<td>Uncatchable process termination</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGPIPE</td>
		<td>Process wrote to a pipe but there are no readers</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGPROF</td>
		<td>Profiling timer expired</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGPWR</td>
		<td>Power failure</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGQUIT</td>
		<td>User generated the quit character(Ctrl-\)</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGSEGV</td>
		<td>Memory access violation</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGSTKFLT</td>
		<td>Coprocessor stack fault</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGSTOP</td>
		<td>Suspends execution of the process</td>
		<td>Stop</td>
	</tr>
	<tr>
		<td>SIGSYS</td>
		<td>Process tried to execute an invalid system call</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGTERM</td>
		<td>Catchable process termination</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGTRAP</td>
		<td>Break point encountered</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGTSTP</td>
		<td>User generated the suspend character(Ctrl-Z)</td>
		<td>Stop</td>
	</tr>
	<tr>
		<td>SIGTTIN</td>
		<td>Background process read from controlling terminal</td>
		<td>Stop</td>
	</tr>
	<tr>
		<td>SIGTTOU</td>
		<td>Background process wrote to controlling terminal</td>
		<td>Stop</td>
	</tr>
	<tr>
		<td>SIGURG</td>
		<td>Urgent I/O pending</td>
		<td>Ignored</td>
	</tr>
	<tr>
		<td>SIGUSR1</td>
		<td>Process-defined signal</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGUSR2</td>
		<td>Process-defined signal</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGVTALRM</td>
		<td>Generated by setitimer() when called with the ITIMER_VIRTUAL flag</td>
		<td>Terminate</td>
	</tr>
	<tr>
		<td>SIGWINCH</td>
		<td>Size of controlling terminal window changed</td>
		<td>Ignored</td>
	</tr>
	<tr>
		<td>SIGXCPU</td>
		<td>Processor resource limits were exceeded</td>
		<td>Terminate with core dump</td>
	</tr>
	<tr>
		<td>SIGXFSZ</td>
		<td>File resource limits were exceeded</td>
		<td>Terminate with core dump</td>
	</tr>
</table>


##Basic Signal Management
```C
#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t signal(int signo, sighandler_t handler);
```
A successful call to `signal()` removes the current action taken on receipt of the signal signo and instead handles the signal with the signal handler specified by handler.

###Waiting for a Signal, Any Signal
```C
#include <unistd.h>

int pause(void);
```
`pause()` returns only if the signal is received, in which case the signal is handled, and `pause()` returns -1 and sets errno to EINTR. If the kernel raises an ignored signal, the process does not wake up.

###Execution and Inheritance
On fork, the child process inherits the signal actions of its parent. That is, the child copies the registered actions(ignore, default, handle) for each signal from its parent. Pending signals are not inherited, which makes sense: the pending signal was sent to a specified pid, decidedly not the child.When a process is created via one of the exec family of system calls, all signals are set to their default actions unless the parent process is ignoring them; in that case, the newly imaged process will also ignore those signals.

###Mapping Signal Numbers to Strings
```C
#include <signal.h>

void psignal(int signo, const char* msg);

#define _GNU_SOURCE
#include <string.h>

char *strsignal(int signo);
```

##Sending a Signal
The `kill()` system call, the basis of the common kill utility, sends a signal from one process to another:

```C
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int signo);
```

In its common use, `kill()` sends the signal signo to the process identified by pid.

If pid is 0, signo is sent to every process in the invoking process's process group.

If pid is -1, signo is sent to every process for which the invoking process has permission to send a signal, except itself and init.

If pid is less than -1, signo is sent to the process group -pid.

###Permissions
In order to send a signal to another process, the sending process needs proper permissions. A process with the CAP_KILL capability(usually one owned by root) can send a signal to any process. Without this capability, the sending process's effective or real user ID must be equal to the real or saved user ID of the receiving process.

###Sending a Signal to Yourself
The `raise()` function is a simple way for a process to send a signal to itself:

```C
#include <signal.h>

int raise(int signo);
// equivalent to the following call:
// kill(getpid(), signo);
```

###Sending a Signal to an Entire Process Group

```C
#include <signal.h>

int killpg(int pgrp, int signo);
// equivalent to the following call:
// kill(-pgrp, signo);
```

##Reentrancy
A reentrant function is a function that is safe to call from within itself(or concurrently, from another thread in the same process). In order to qualify as reentrant, a function must not manipulate static data, must manipulate only stack-based data or data provided to it by the caller, must not invoke any nonreentrant function.

###Guaranteed-Reentrant Functions
When writing a signal handler, you have to assume that the interrupted process could in the middle of a nonreentrant function(or anything else, for that matter). Thus, signal handlers must make use only of functions that are reentrant.

*Table: Functions guaranteed to be safely reentrant for use in signals*

<table>
	<tr>
		<td>abort()</td>
		<td>accept()</td>
		<td>access()</td>
	</tr>
	<tr>
		<td>aio_error()</td>
		<td>aio_return()</td>
		<td>aio_suspend()</td>
	</tr>
	<tr>
		<td>alarm()</td>
		<td>bind()</td>
		<td>cfgetispeed()</td>
	</tr>
	<tr>
		<td>cfgetospeed()</td>
		<td>fsetispeed()</td>
		<td>cfsetospeed()</td>
	</tr>
	<tr>
		<td>chdir()</td>
		<td>chmod()</td>
		<td>chown()</td>
	</tr>
	<tr>
		<td>clock_gettime()</td>
		<td>close()</td>
		<td>connect()</td>
	</tr>
	<tr>
		<td>creat()</td>
		<td>dup()</td>
		<td>dup2()</td>
	</tr>
	<tr>
		<td>execle()</td>
		<td>execve()</td>
		<td>_Exit()</td>
	</tr>
	<tr>
		<td>_exit()</td>
		<td>fchmod()</td>
		<td>fchown()</td>
	</tr>
	<tr>
		<td>fcntl()</td>
		<td>fdatasync()</td>
		<td>fork()</td>
	</tr>
	<tr>
		<td>fpathconf()</td>
		<td>fstat()</td>
		<td>fsync()</td>
	</tr>
	<tr>
		<td>ftruncate()</td>
		<td>getegid()</td>
		<td>geteuid()</td>
	</tr>
	<tr>
		<td>getgid()</td>
		<td>getgroups()</td>
		<td>getpeername()</td>
	</tr>
	<tr>
		<td>getpgrp()</td>
		<td>getpid()</td>
		<td>getppid()</td>
	</tr>
	<tr>
		<td>getsockname()</td>
		<td>getsockopt()</td>
		<td>getuid()</td>
	</tr>
	<tr>
		<td>kill()</td>
		<td>link()</td>
		<td>listen()</td>
	</tr>
	<tr>
		<td>lseek()</td>
		<td>lstat()</td>
		<td>mkdir()</td>
	</tr>
	<tr>
		<td>mkfifo()</td>
		<td>open()</td>
		<td>pathconf()</td>
	</tr>
	<tr>
		<td>pause()</td>
		<td>pipe()</td>
		<td>poll()</td>
	</tr>
	<tr>
		<td>posix_trace_event()</td>
		<td>pselect()</td>
		<td>raise()</td>
	</tr>
	<tr>
		<td>read()</td>
		<td>readlink()</td>
		<td>recv()</td>
	</tr>
	<tr>
		<td>recvfrom()</td>
		<td>recvmsg()</td>
		<td>rename()</td>
	</tr>
	<tr>
		<td>rmdir()</td>
		<td>select()</td>
		<td>sem_post()</td>
	</tr>
	<tr>
		<td>send()</td>
		<td>sendmsg()</td>
		<td>sendto()</td>
	</tr>
	<tr>
		<td>setgid()</td>
		<td>setpgid()</td>
		<td>setsid()</td>
	</tr>
	<tr>
		<td>setsockopt()</td>
		<td>setuid()</td>
		<td>shutdown()</td>
	</tr>
	<tr>
		<td>sigaction()</td>
		<td>sigaddset()</td>
		<td>sigdelset()</td>
	</tr>
	<tr>
		<td>sigemptyset()</td>
		<td>sigfillset()</td>
		<td>sigismember()</td>
	</tr>
	<tr>
		<td>signal()</td>
		<td>sigpause()</td>
		<td>sigpending()</td>
	</tr>
	<tr>
		<td>sigprocmask()</td>
		<td>sigqueue()</td>
		<td>sigset()</td>
	</tr>
	<tr>
		<td>sigsuspend()</td>
		<td>sleep()</td>
		<td>socket()</td>
	</tr>
	<tr>
		<td>socketpair()</td>
		<td>stat()</td>
		<td>symlink()</td>
	</tr>
	<tr>
		<td>sysconf()</td>
		<td>tcdrain()</td>
		<td>tcflow()</td>
	</tr>
	<tr>
		<td>tcflush()</td>
		<td>tcgetattr()</td>
		<td>tcgetpgrp()</td>
	</tr>
	<tr>
		<td>tcsendbreak()</td>
		<td>tcsetattr()</td>
		<td>tcsetpgrp()</td>
	</tr>
	<tr>
		<td>time()</td>
		<td>timer_getoverrun()</td>
		<td>timer_gettime()</td>
	</tr>
	<tr>
		<td>timer_settime()</td>
		<td>times()</td>
		<td>umask()</td>
	</tr>
	<tr>
		<td>uname()</td>
		<td>unlink()</td>
		<td>utime()</td>
	</tr>
	<tr>
		<td>wait()</td>
		<td>waitpid()</td>
		<td>write()</td>
	</tr>
</table>

##Signal Sets
```C
#include <signal.h>

int sigemptyset(sigset_t *set);

int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signo);

int sigdelset(sigset_t *set, int signo);

int sigismember(const sigset_t *set, int signo);

// nonstandard functions
int sigsempty(sigset_t *set);
int sigorset(sigset_t *dest, sigset_t *left, sigset_t *right);
int sigandset(sigset_t *dest, sigset_t *left, sigset_t *right);
```

##Blocking Signals
Any signals that are raised while blocked are not handled until they are unblocked. A process may block any number of signals; the set of signals blocked by a process is called its signal mask.

```C
#include <signal.h>

int sigprocmask(int how,
				 const sigset_t *set,
				 sigset_t *oldset);
				 
// the behavior of sigprocmask() depends on the value of how, 
// which is one of the following flags:
// SIG_SETMASK : the signal mask for the invoking process is changed to set
// SIG_BLOCK : the signals in set are added to the invoking process's signal mask
// SIG_UNBLOCK : the signals in set are removed from the invoking process's signal mask
```

###Retrieving Pending Signals
When the kernel raises a blocked signal, it is not delivered. We call such signals pending. When a pending signal is unblocked, the kernel then passes it off to the process to handle.

```C
#include <signal.h>

int sigpending(sigset_t *set);
```

A successful call to `sigpending()` places the set of pending signals in set and returns 0.

###Waiting for a Set of Signals
A third POSIX-defined function allows a process to temporarily change its signal mask and then wait until a signal is raised that either terminates or is handled by the process:

```C
#include <signal.h>

int sigsuspend(const sigset_t *set);
```

##Advanced Signal Management
```C
#include <signal.h>

int sigaction(int signo,
			   const struct sigaction *act,
			   struct sigaction *oldact);
			   
struct sigaction {
	void (*sa_handler)(int);
	void (*sa_sigaction)(int, siginfo_t *, void *);
	sigset_t sa_mask;
	int sa_flags;
	void (*sa_restorer)(void);
};

typedef struct siginfo_t {
	int si_signo;
	int si_errno;
	int si_code;
	pid_t si_pid;
	uid_t si_uid;
	int si_status;
	clock_t si_utime;
	clock_t si_stime;
	sigval_t si_value;
	int si_int;
	void *si_ptr;
	void *si_addr;
	int si_band;
	int si_fd;
};
```

A call to `sigaction()` changes the behavior of the signal identified by signo, which can be any value except those associated with SIGKILL and SIGSTOP.

##Sending a Signal with a Payload
```C
#include <signal.h>

int sigqueue(pid_t pid,
			 int signo,
			 const uion sigval value);

union sigval {
	int sival_int;
	void *sival_ptr;
};
```